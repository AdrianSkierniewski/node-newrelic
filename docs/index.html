<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-Context-Preservation.html">Transaction State Preservation</a></li><li class="nav-item"><a href="tutorial-Datastore-Simple.html">Intro to Datastore Instrumentation</a></li><li class="nav-item"><a href="tutorial-Instrumentation-Basics.html">Instrumentation Basics</a></li><li class="nav-item"><a href="tutorial-Webframework-Simple.html">Intro to Web Framework Instrumentation</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="API.html">API</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#addCustomParameter">addCustomParameter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#addCustomParameters">addCustomParameters</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#addIgnoringRule">addIgnoringRule</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#addNamingRule">addNamingRule</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#createTracer">createTracer</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#createWebTransaction">createWebTransaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#getBrowserTimingHeader">getBrowserTimingHeader</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#instrument">instrument</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#instrumentDatastore">instrumentDatastore</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#instrumentWebframework">instrumentWebframework</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#noticeError">noticeError</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#setControllerName">setControllerName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#setDispatcher">setDispatcher</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#setIgnoreTransaction">setIgnoreTransaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#setTransactionName">setTransactionName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="API.html#shutdown">shutdown</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="DatastoreShim.html">DatastoreShim</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#bindRowCallbackSegment">bindRowCallbackSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#captureInstanceAttributes">captureInstanceAttributes</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#parseQuery">parseQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#recordBatchQuery">recordBatchQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#recordOperation">recordOperation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#recordQuery">recordQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#setDatastore">setDatastore</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DatastoreShim.html#setParser">setParser</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Shim.html">Shim</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#applySegment">applySegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#argsToArray">argsToArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#bindCallbackSegment">bindCallbackSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#bindCreateTransaction">bindCreateTransaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#bindSegment">bindSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#createSegment">createSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#defineProperties">defineProperties</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#defineProperty">defineProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#execute">execute</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#getName">getName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#getSegment">getSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isArray">isArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isBoolean">isBoolean</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isFunction">isFunction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isNumber">isNumber</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isObject">isObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isPromise">isPromise</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isString">isString</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#isWrapped">isWrapped</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#listenerCount">listenerCount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#normalizeIndex">normalizeIndex</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#once">once</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#proxy">proxy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#record">record</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#setDefaults">setDefaults</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#setInternalProperty">setInternalProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#storeSegment">storeSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#toArray">toArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#unwrap">unwrap</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#wrap">wrap</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#wrapClass">wrapClass</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#wrapExport">wrapExport</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Shim.html#wrapReturn">wrapReturn</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="TransactionShim.html">TransactionShim</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="TransactionShim.html#popTransactionName">popTransactionName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="TransactionShim.html#pushTransactionName">pushTransactionName</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="TransactionShim.html#setTransactionName">setTransactionName</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="WebFrameworkShim.html">WebFrameworkShim</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#captureUrlParams">captureUrlParams</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#errorHandled">errorHandled</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#noticeError">noticeError</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#recordMiddleware">recordMiddleware</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#recordParamware">recordParamware</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#recordRender">recordRender</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#setErrorPredicate">setErrorPredicate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#setFramework">setFramework</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#setRouteParser">setRouteParser</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#setTransactionUri">setTransactionUri</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WebFrameworkShim.html#wrapMiddlewareMounter">wrapMiddlewareMounter</a></span></li><li class="nav-heading">Interfaces</li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="DatastoreExtras.html">DatastoreExtras</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="MiddlewareMounterSpec.html">MiddlewareMounterSpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="MiddlewareSpec.html">MiddlewareSpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="OperationSpec.html">OperationSpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="global.html#ParsedQueryData">ParsedQueryData</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="QuerySpec.html">QuerySpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="RecorderSpec.html">RecorderSpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="RenderSpec.html">RenderSpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="SegmentSpec.html">SegmentSpec</a></span></li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="TransactionSpec.html">TransactionSpec</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#shimRequire">shimRequire</a></span></li>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><p><a href="https://nodei.co/npm/@newrelic/beta-agent"><img src="https://nodei.co/npm/@newrelic/beta-agent.png" alt="npm status badge"></a></p>
<h1>WARNING - Beta</h1><p><strong>This is beta software. For critical systems you should use the
<a href="https://www.npmjs.com/package/newrelic">stable New Relic package</a></strong>. The beta Node Agent requires a beta token.
Getting a token is easy!</p>
<ol>
<li>Agree to the click-through <a href="https://docs.google.com/a/newrelic.com/forms/d/e/1FAIpQLSfI7wMEaBgP6ywZ4m9bBiNWiCwPbO6wGLoiXh62HI8RIqhTlA/viewform">Beta Agreement</a>.</li>
<li>Once your account is approved, we will email you a beta token, usually
within the same business day.</li>
<li>Add the beta token to your config <a href="#getting-started">(see below for details)</a>.</li>
</ol>
<p>Please join our <a href="https://discuss.newrelic.com/c/language-agents/node-js-agent">Node Agent Forum</a> to tell us how the beta features in the
Node Agent work for you, what you'd like to see and how we can improve it. We're
eager to hear your feedback!</p>
<p>Breaking changes may be made before this is released. Please see our new
<a href="https://newrelic.github.io/node-newrelic">API documentation</a> for more details
on how to use the new features in this Beta.</p>
<h1>New Relic for Node.js</h1><p>This package instruments your application for performance monitoring
with <a href="https://newrelic.com">New Relic</a>.</p>
<p>Make sure you have a <a href="https://newrelic.com">New Relic account</a> before starting. To see all the
features, such as slow transaction traces, you will need a <a href="https://newrelic.com/application-monitoring/features">New Relic Pro</a>
subscription (or equivalent).</p>
<p>As with any instrumentation tool, please test before using in production.</p>
<h2>Table of contents</h2><ul>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#configuring-the-module">Configuration</a></li>
<li><a href="#browser-timings-rum--real-user-monitoring">RUM / browser timings</a></li>
<li><a href="#transactions-and-request-naming">Transactions and request naming</a></li>
<li><a href="#license">Licensing</a></li>
<li><a href="#contributions">Contributions</a></li>
<li><a href="#known-issues">Known issues</a></li>
</ul>
<h2>Getting started</h2><ol>
<li><a href="https://nodejs.org/#download">Install node</a>. The agent runs on v0.10 and
higher. Development work on this module is done with the latest
non-development release of Node.</li>
<li>Verify your version of node came with a new enough version of npm using
<code>npm -v</code>. We require version 1.4.28 or newer, and recommend using
the latest release. Read more about <a href="#upgrading-npm">upgrading npm here</a>.</li>
<li>Install this module via <code>npm install @newrelic/beta-agent</code> for the
application you want to monitor.</li>
<li>Copy <code>newrelic.js</code> from <code>node_modules/@newrelic/beta-agent</code> into the root
directory of your application.</li>
<li>Edit <code>newrelic.js</code> and replace <code>license_key</code>'s value with the license key
for your account. Also replace <code>beta_token</code>'s value with the beta token we
have emailed you.</li>
<li>Add <code>require('@newrelic/beta-agent');</code> as the first line of the app's main module.</li>
</ol>
<p>If you wish to keep the configuration for the module separate from your
application, the module will look for <code>newrelic.js</code> in the directory referenced
by the environment variable <code>NEW_RELIC_HOME</code> if it's set.</p>
<p>When you start your app, New Relic should start up with it and start reporting
data that will appear within <a href="https://rpm.newrelic.com/">the New Relic UI</a>
after a few minutes. Because the agent minimizes the amount of bandwidth it
consumes, it only reports data once a minute, so if you require the module in
tests that take less than a minute to run, it won't have time to report data to
New Relic. The module will write its log to a file named <code>newrelic_agent.log</code>
in the application directory. If New Relic doesn't send data or crashes your
app, the log can help New Relic determine what went wrong, so be sure to send
it along with any bug reports or support requests.</p>
<h3>Upgrading npm</h3><p>If you're running on a version of npm before 1.4.28, or are interested in moving
up to latest follow these steps:</p>
<ol>
<li>Run <code>npm -v</code> to make sure you have npm installed and working.</li>
<li>If you are on linux/smartos/osx/*nix run <code>ls -l $(which npm)</code> and check to
see if the file is owned by &quot;root&quot; or &quot;admin&quot;. If so, prefix the next command
with <code>sudo</code>.</li>
<li>Run <code>npm install -g npm@latest</code> to upgrade npm itself.</li>
</ol>
<p><strong>Warning</strong>: An existing installation of npm can break if it is used to upgrade
itself without root privileges while the npm executable is owned by root.</p>
<h2>Security</h2><p>We take security (and the protection of your and your users' privacy) very
seriously. See <a href="SECURITY.md">SECURITY.md</a> for details, but the brief version is
that if you feel you've found a security issue, contact us at security@newrelic.com.</p>
<h2>Configuring the module</h2><p>The module can be tailored to your app's requirements, both from the server and
via the <code>newrelic.js</code> configuration file you created. For complete details on
what can be configured, refer to <a href="https://github.com/newrelic/node-newrelic/blob/master/lib/config.default.js"><code>lib/config.default.js</code></a>, which documents
the available variables and their default values.</p>
<p>In addition, for those of you running in PaaS environments like Heroku or
Microsoft Azure, all of the configuration variables in <code>newrelic.js</code> have
counterparts that can be set via environment variables. You can mix and match
variables in the configuration file and environment variables freely;
environment variables take precedence.</p>
<p>Here's the list of the most important variables and their values:</p>
<ul>
<li><code>NEW_RELIC_BETA_TOKEN</code>: Your New Relic Agent Beta token. This is a required
setting for the beta agent with no default value.</li>
<li><code>NEW_RELIC_LICENSE_KEY</code>: Your New Relic license key. This is a required
setting with no default value.</li>
<li><code>NEW_RELIC_APP_NAME</code>: The name of this application, for reporting to New
Relic's servers. This value can be also be a comma-delimited list of names.
This is a required setting with no default value. (NOTE: as a convenience to
Azure users, the module will use <code>APP_POOL_ID</code> as the application name if
it's set, so you can use the name you chose for your Azure Web Server without
setting it twice.)</li>
<li><code>NEW_RELIC_NO_CONFIG_FILE</code>: Inhibit loading of the configuration file
altogether. Use with care. This presumes that all important configuration
will be available via environment variables, and some log messages assume
that a config file exists.</li>
<li><code>NEW_RELIC_HOME</code>: path to the directory in which you've placed <code>newrelic.js</code>.</li>
<li><code>NEW_RELIC_USE_SSL</code>: Use SSL for communication with New Relic's servers.
Enabled by default.</li>
<li><code>NEW_RELIC_LOG</code>: Complete path to the New Relic agent log, including the
filename. The agent will shut down the process if it can't create this file,
and it creates the log file with the same umask of the process. Setting this
to <code>stdout</code> will write all logging to stdout, and <code>stderr</code> will write all
logging to stderr.</li>
<li><code>NEW_RELIC_LOG_LEVEL</code>: Logging priority for the New Relic agent. Can be one
of <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, or <code>trace</code>. <code>debug</code> and <code>trace</code> are
pretty chatty; unless you're helping New Relic figure out irregularities with
the module, you're probably best off using <code>info</code> or higher.</li>
</ul>
<p>For completeness, here's the rest of the list:</p>
<ul>
<li><code>NEW_RELIC_ENABLED</code>: Whether or not the agent should run. Good for
temporarily disabling the agent while debugging other issues with your code.
It doesn't prevent the module from bootstrapping its instrumentation or
setting up all its pieces, it just prevents it from starting up or connecting
to New Relic's servers. Defaults to true.</li>
<li><code>NEW_RELIC_ERROR_COLLECTOR_ENABLED</code>: Whether or not to trace errors within
your application. Values are <code>true</code> or <code>false</code>. Defaults to true.</li>
<li><code>NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES</code>: Comma-delimited list of HTTP
status codes to ignore. Maybe you don't care if payment is required? Ignoring
a status code means that the transaction is not renamed to match the code,
and the request is not treated as an error by the error collector. Defaults
to ignoring 404.</li>
<li><code>NEW_RELIC_IGNORE_SERVER_CONFIGURATION</code>: Whether to ignore server-side
configuration for this application. Defaults to false.</li>
<li><code>NEW_RELIC_TRACER_ENABLED</code>: Whether to collect and submit slow transaction
traces to New Relic. Values are <code>true</code> or <code>false</code>. Defaults to true.</li>
<li><code>NEW_RELIC_TRACER_THRESHOLD</code>: Threshold of web transaction response time (in
seconds) at which a transaction trace will count as slow and be sent to New
Relic. Can also be set to <code>apdex_f</code>, at which point it will set the trace
threshold to 4 times the current ApdexT. Defaults to <code>apdex_f</code>.</li>
<li><code>NEW_RELIC_APDEX</code>: Set the initial Apdex tolerating / threshold value in
seconds.  This is more often than not set from the server. Defaults to 0.100.</li>
<li><code>NEW_RELIC_CAPTURE_PARAMS</code>: Whether to capture request parameters on slow
transaction or error traces. Defaults to false.</li>
<li><code>NEW_RELIC_IGNORED_PARAMS</code>: Some parameters may contain sensitive values you
don't want being sent out of your application. This setting is a
comma-delimited list of names of parameters to ignore. Defaults to empty.</li>
<li><code>NEW_RELIC_NAMING_RULES</code>: A list of comma-delimited JSON object literals:
<code>NEW_RELIC_NAMING_RULES='{&quot;pattern&quot;:&quot;^t&quot;,&quot;name&quot;:&quot;u&quot;},{&quot;pattern&quot;:&quot;^u&quot;,&quot;name&quot;:&quot;t&quot;}'</code>
See the section on request and transaction naming for details. Defaults to
empty.</li>
<li><code>NEW_RELIC_IGNORING_RULES</code>: A list of comma-delimited patterns:
<code>NEW_RELIC_IGNORING_RULES='^/socket\.io/.*/xhr-polling,ignore_me'</code> Note that
currently there is no way to escape commas in patterns. Defaults to empty.</li>
<li><code>NEW_RELIC_TRACER_TOP_N</code>: Increase this number to increase the diversity of
slow transaction traces sent to New Relic. Defaults to 1. See the description
in <code>lib/config.default.js</code>, as this feature is exceedingly hard to summarize.</li>
<li><code>NEW_RELIC_HOST</code>: Hostname for the New Relic collector. You shouldn't
need to change this.</li>
<li><code>NEW_RELIC_PORT</code>: Port number on which the New Relic collector will be
listening. You shouldn't need to change this either.</li>
<li><code>NEW_RELIC_PROXY_URL</code>: A fully-qualified URL to an http/https proxy.
The proxy URL may include basic authentication.
The use of <code>NEW_RELIC_PROXY_URL</code> overrides other proxy settings.</li>
<li><code>NEW_RELIC_PROXY_HOST</code>: Proxy hostname</li>
<li><code>NEW_RELIC_PROXY_PORT</code>: Proxy port.</li>
<li><code>NEW_RELIC_PROXY_USER</code>: Proxy user name (basic auth only).</li>
<li><code>NEW_RELIC_PROXY_PASS</code>: Proxy password.</li>
<li><code>NEW_RELIC_DEBUG_METRICS</code>: Whether to collect internal supportability metrics
for the agent. Don't mess with this unless New Relic asks you to.</li>
<li><code>NEW_RELIC_DEBUG_TRACER</code>: Whether to dump traces of the transaction tracer's
internal operation. It's unlikely to be informative unless you're a New Relic
Node.js engineer and it has a significant performance cost, so use with care.</li>
<li><code>NEW_RELIC_BROWSER_MONITOR_ENABLE</code>: Whether to generate browser timing (RUM)
headers or not.</li>
<li><code>NEW_RELIC_LABELS</code>: Sets the label names and values to associate with the
application. The list is a semi-colon delimited list of colon-separated name
and value pairs</li>
</ul>
<h2>Browser timings (RUM / Real User Monitoring)</h2><p>New Relic's instrumentation can extend beyond your application into the
client's browser.  The <code>newrelic</code> module can generate <code>&lt;script&gt;</code> headers which,
when inserted into your HTML templates, will capture client-side page load
times.</p>
<p>Headers must be manually injected, but no extra configuration is necessary to
enable browser timings.</p>
<h3>Basics</h3><ul>
<li>Insert the result of <code>newrelic.getBrowserTimingHeader()</code> into your html page.</li>
<li>The browser timing headers should be placed in the beginning of your <code>&lt;head&gt;</code> tag.<ul>
<li>As an exception to the above, for maximum IE compatability, the results of
<code>getBrowserTimingHeader()</code> should be placed <em>after</em> any
<code>X-UA-COMPATIBLE HTTP-EQUIV</code> meta tags.</li>
</ul>
</li>
<li>Do <em>not</em> cache the header, call it once for every request.</li>
</ul>
<h3>Example</h3><p>Below is an example using <code>express</code> and <code>jade</code>; Express is a popular web
application framework, and <code>jade</code> is a popular template module.  Although the
specifics are different for other frameworks, the general approach described
below should work in most cases.</p>
<p>The simplest way to insert browser timing headers is to pass the <code>newrelic</code>
module into your template, and call <code>newrelic.getBrowserTimingHeader()</code> from
within the template.</p>
<p><em>app.js:</em></p>
<pre class="prettyprint source lang-javascript"><code>var newrelic = require('@newrelic/beta-agent');
var app = require('express')();

// In Express, this lets you call newrelic from within a template.
app.locals.newrelic = newrelic;

app.get('/user/:id', function (req, res) {
  res.render('user');
});
app.listen(process.env.PORT);</code></pre><p><em>layout.jade:</em></p>
<pre class="prettyprint source lang-jade"><code>doctype html
html
  head
    != newrelic.getBrowserTimingHeader()
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
  body
    block content</code></pre><p>By defaults calls to <code>newrelic.getBrowserTimingHeader()</code> should return valid
headers.  You can disable header generation <em>without</em> removing your template
code.  In your <code>newrelic.js</code> file, add the following to disable header
generation.</p>
<pre class="prettyprint source lang-javascript"><code>exports.config = {
  // ... other config
  browser_monitoring : {
    enable : false
  }
};</code></pre><p>You can also set the environment variable <code>NEW_RELIC_BROWSER_MONITOR_ENABLE=false</code>.</p>
<p>It is safe to leave the header generation code in place even when you're not
using it.  If browser timings are disabled, or there is an error such that
working headers cannot be generated, the <code>newrelic</code> module will generate an
innocuous HTML comment.  If the <code>newrelic</code> module is disabled entirely no
content will be generated.</p>
<h2>Transactions and request naming</h2><p>In order to get the most value out of New Relic for Node.js, you may have to do
a little work to help us figure out how your application is structured. New
Relic works on the assumption that it can group requests to your application
into transactions, which are defined by giving one or more request paths a
name. These names are used to visualize where your app is spending its time (in
transaction breakdowns), to identify slow requests, and to group scoped
metrics. For example, this can identify slow database queries by showing which
requests are spending a long time waiting on the database.</p>
<p>If you're using Express, Restify or Hapi with their default routers and are
satisfied with your application being represented by those frameworks' route
matchers, you may not need to do anything. However, if you want more specific
names than are provided by your framework, you may want to use one or more of
the tools described further on.</p>
<p>The simplest way to tell that you need to read further in this document is if
you feel too many of your requests are being lumped together under the
catch-all name <code>/*</code>. All requests that aren't otherwise named by the module
will end up grouped under <code>/*</code>.</p>
<h3>Background</h3><p>If you've been working with Node for a while, you're probably accustomed to
thinking of your application's requests in terms of raw URLs. One of the great
things about Node is that it makes it so easy and simple to work with HTTP, and
that extends to things like parsing URLs and creating your own strategies for
naming and routing requests for services like RESTful APIs. This presents a
challenge for New Relic, because we need to keep the number of names we're
tracking small enough that we can keep the New Relic user experience snappy,
and also so we don't overwhelm you with so much data that it's difficult for
you to see the problem spots in your applications. URLs are not a good fit for
how New Relic sees performance.</p>
<p>Another of Node's great strengths is that it provides a lot of tools that build
on top of the <code>http</code> module to simplify writing web services. Unfortunately,
that variety greatly complicates things for us, with our limited resources, and
so we offer a few different tools to help you give us the information we need
to provide you useful metrics about your application:</p>
<ul>
<li>we can read the route names from the Express, Restify, and Hapi routers, if
you're using them (and as said above, for many of you, this may be all you
need)</li>
<li>we offer an API for naming the current request, either with simple names or,
if you prefer, grouped into controllers with actions</li>
<li>and we support rules stored in your module's configuration that can mark
requests to be renamed or ignored based on regular expressions matched
against the request's raw URLs (also available as API calls)</li>
</ul>
<p>Requests are mapped to transaction names using a deterministic process:</p>
<ol>
<li>On an incoming request, the module creates a New Relic transaction that
includes the HTTP request method and other metadata. As a fallback (for use
in the error tracer), each transaction is named after its raw request URL.</li>
<li>When a framework using a supported router is in use, the agent copies the
framework name, route path and request method onto the transaction as its
transaction name.</li>
<li>Within handlers, you can make calls to the module's API to explicitly set
the name of the route to whatever you want, or mark the route to be ignored
(or explicitly not ignored, see the below discussion of rules). As noted
below, the last API call wins when there is more than one.</li>
<li>When the transaction is finished (i.e. the response has been completely
streamed out to the client), any naming or ignoring rules you have specified
in your configuration are applied. <strong>NOTE:</strong> Older versions of the module
only applied these rules if nothing else had named the transaction, which
made using rules with router-based automatic naming impossible. You must be
using the latest version of New Relic to combine naming and ignoring rules
with naming set by the router instrumentation.</li>
<li>Finally, New Relic may have its own rules that it applies to the transaction
name, either because the request is for something New Relic rolls up by
default (i.e. static assets like images or CSS files), or because New Relic
is applying rules to remedy metric grouping issues.</li>
<li>If nothing has named the transaction after steps 1-5, the transaction is
named <code>/*</code>, which puts that request in the undifferentiated, default bucket
for requests. This will typically only happen in situations where your
application uses either no framework, or a framework with a router that
isn't currently supported by New Relic.</li>
</ol>
<p>Let's go through the naming tools one at a time.</p>
<h3>Router introspection</h3><p>Express is the most popular web framework in use within the Node community, and
a number of important services are also using Restify. Both frameworks map
routes to handlers, and both use a similar pattern to do so: they match one or
more HTTP methods (e.g. <code>GET</code> or the ever-popular <code>OPTIONS</code> – let's hear it for
CORS) along with a potentially parameterized path (e.g. <code>/user/:id</code>) or a
regular expression (e.g.  <code>/^/user/([-0-9a-f]+)$/</code>). New Relic will capture
both those pieces of information in the request name. If you have support for
slow transaction traces and have enabled <code>capture_params</code>, the transaction
trace will also have the request's parameters and their values attached to it.
Likewise, request parameters and their values will be attached to any errors
recorded by the agent.</p>
<p>The only important thing to know about New Relic's support for Express, Restify,
or Hapi is that if you're dissatisfied with the names it comes up with, you can
use the API calls described below to come up with more descriptive names. Also,
if you use a different web framework or router and would like to see support
for it added, please let us know.</p>
<h3>Request naming with the module API</h3><p>The API is what's handed back from <code>require('@newrelic/beta-agent')</code>, so</p>
<pre class="prettyprint source lang-javascript"><code>var newrelic = require('@newrelic/beta-agent');</code></pre><p>is all you need. Please note that you still need to ensure that loading the New
Relic module is the first thing your application does, as it needs to bootstrap
itself before the rest of your application loads, but you can safely require
the module from multiple modules in your application – it will only initialize
itself once.</p>
<h4>newrelic.setTransactionName(name)</h4><p>Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.</p>
<p>Explicitly calling <code>newrelic.setTransactionName()</code> will override any names set
by Express, Restify or Hapi routes. Calls to <code>newrelic.setTransactionName()</code> and
<code>newrelic.setControllerName()</code> will overwrite each other. The last call made
before the request ends wins.</p>
<p><strong>VERY IMPORTANT NOTE:</strong> Do not include highly variable information like GUIDs,
numerical IDs, or timestamps in the request names you create. If your request
is slow enough to generate a transaction trace, that trace will contain the
original URL. If you enable parameter capture, the parameters will also be
attached to the trace. The request names are used to group requests for New
Relic's many charts and tables, and those visualizations' value drops as the
number of different request names increases. If you have 50 or so different
transaction names, you're probably pushing it. If you have more than a couple
hundred, you need to rethink your naming strategy.</p>
<h4>newrelic.setControllerName(name, [action])</h4><p>Name the current request using a controller-style pattern, optionally including
the current controller action. If the action is omitted, New Relic will include
the HTTP method (e.g. <code>GET</code>, <code>POST</code>) as the action. The rules for when you can
call <code>newrelic.setControllerName()</code> are the same as they are for
<code>newrelic.setTransactionName()</code>.</p>
<p>Explicitly calling <code>newrelic.setControllerName()</code> will override any names set by
Express, Restify, or Hapi routes. Calls to <code>newrelic.setTransactionName()</code> and
<code>newrelic.setControllerName()</code> will overwrite each other. The last one to run
before the request ends wins.</p>
<p>See the above note on <code>newrelic.setTransactionName()</code>, which also applies to
this function.</p>
<h3>Rules for naming and ignoring requests</h3><p>If you don't feel like putting calls to the New Relic module directly into your
application code, you can use pattern-based rules to name requests. There are
two sets of rules: one for renaming requests, and one to mark requests to be
ignored by New Relic.</p>
<p>If you're using socket.io, you will have a use case for ignoring rules right
out of the box. You'll probably want to add a rule like the following:</p>
<pre class="prettyprint source lang-javascript"><code>// newrelic.js
exports.config = {
  // other configuration
  rules : {
    ignore : [
      '^/socket.io/.*/xhr-polling'
    ]
  }
};</code></pre><p>This will keep socket.io long-polling from dominating your response-time
metrics and blowing out the apdex metrics for your application.</p>
<h4>rules.name</h4><p>A list of rules used to set the name of the transaction to <code>name</code> when the URL
matches <code>pattern</code>.</p>
<p>Can also be set via the environment variable <code>NEW_RELIC_NAMING_RULES</code>, with
multiple rules passed in as a list of comma-delimited JSON object literals:
<code>NEW_RELIC_NAMING_RULES='{&quot;pattern&quot;:&quot;^t&quot;,&quot;name&quot;:&quot;u&quot;},{&quot;pattern&quot;:&quot;^u&quot;,&quot;name&quot;:&quot;t&quot;}'</code></p>
<p>Each rule is defined using the following format:</p>
<pre class="prettyprint source"><code>{
  // required
  pattern : &quot;pattern&quot;,
  name : &quot;name&quot;,

  // optional
  precedence: 1,
  terminate_chain: true,
  replace_all: false
}</code></pre><p>Additional attributes are ignored.</p>
<p>Note: these rules take precedence over automatic naming from router instrumentations and
are applied to the URL path, not the name returned by the router instrumentation.</p>
<h5>pattern (required)</h5><p>The pattern used to match the URL.  It can be set as either a string or a JavaScript
regular expression literal.  For example, <code>&quot;^/abc/123$&quot;</code> is equivalent to <code>/^\/abc\/123$/</code>.</p>
<p>The pattern can be written to match the complete URL, or just a part of it.</p>
<h5>name (required)</h5><p>The value that is used to replace the URL (or part of it) that matches the pattern.
It is also possible to use regular expression group references.  See examples below.</p>
<h5>rules.precedence (optional)</h5><p>By default the rules are evaluated in reverse order (from last to first).  If you find
this behavior counterintuitive, the execution order can be reversed by setting the feature
flag <code>reverse_naming_rules</code> to false.  Furthermore, if you prefer to have complete
control over the order, each rule can be given a <code>precedence</code> attribute.  The precedence
is an integer number, and rules are evaluated in ascending order.  If precedence is not
explicitly defined, it will be set to 500 by default.</p>
<h5>rules.terminate_chain (optional)</h5><p>When set to true, no further rules will be evaluated if this rule is a match.  The default
is true.</p>
<p>Setting this to false is useful when multiple rules should be used together.  For example,
one rule could be replacing a common pattern in many different URLs, while subsequent
rule(s) would be more specific.</p>
<h5>rules.replace_all (optional)</h5><p>When set to true, all matches of the pattern will be replaced.  Otherwise, only the first
match will be replaced.  The default is false.  Using the <code>g</code> flag with regular expression
literal will have the same effect.  For example:</p>
<pre class="prettyprint source"><code>  pattern: '[0-9]+',
  replace_all: true</code></pre><p>will have the same effect as</p>
<pre class="prettyprint source"><code>  pattern: /[0-9]+/g</code></pre><h5>Testing</h5><p>The agent comes with a command-line tool for testing naming rules.  For more information
run the following command in terminal window in a directory where your app is installed.</p>
<p><code>node node_modules/.bin/newrelic-naming-rules</code></p>
<h5>Examples</h5><p>Match full URL:</p>
<pre class="prettyprint source"><code>  pattern: &quot;^/items/[0-9]+$&quot;,
  name: &quot;/items/:id&quot;</code></pre><p>Replace the first match in any URL:</p>
<pre class="prettyprint source"><code>  pattern: &quot;[0-9]+&quot;,
  name: &quot;:id&quot;</code></pre><p>will result in:</p>
<p><code>/orders/123</code> =&gt; <code>/orders/:id</code></p>
<p><code>/items/123</code> =&gt; <code>/items/:id</code></p>
<p><code>/orders/123/items/123</code> =&gt; <code>/orders/:id/items/123</code></p>
<p>Replace all matches in any URL:</p>
<pre class="prettyprint source"><code>  pattern: &quot;[0-9]+&quot;,
  name: &quot;:id&quot;,
  replace_all: true</code></pre><p>will result in:</p>
<p><code>/orders/123/items/123</code> =&gt; <code>/orders/:id/items/:id</code></p>
<p>Using regular expression match group references:</p>
<pre class="prettyprint source"><code>  pattern: '^/(items|orders)/[0-9]+$',
  name: '/\\1/:id'</code></pre><p>will result in:</p>
<p><code>/orders/123</code> =&gt; <code>/orders/:id</code></p>
<p><code>/items/123</code> =&gt; <code>/items/:id</code></p>
<h4>rules.ignore</h4><p>A list of patterns for matching incoming request URLs to be ignored. When using
ignoring rules with instrumented routers, the matches are still made against
the URL paths, not the name returned by the router instrumentation. Patterns may be
strings or regular expressions.</p>
<p>Can also be set via the environment variable <code>NEW_RELIC_IGNORING_RULES</code>, with
multiple rules passed in as a list of comma-delimited patterns:
<code>NEW_RELIC_IGNORING_RULES='^/socket\.io/\*/xhr-polling,ignore_me'</code> Note that
currently there is no way to escape commas in patterns.</p>
<h3>API for adding naming and ignoring rules</h3><h4>newrelic.addNamingRule(pattern, name)</h4><p>Programmatic version of <code>rules.name</code> above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module's
configuration. Both parameters are mandatory.</p>
<h4>newrelic.addIgnoringRule(pattern)</h4><p>Programmatic version of <code>rules.ignore</code> above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module's
configuration. The pattern is mandatory.</p>
<h3>Other API calls</h3><h4>newrelic.addCustomParameter(name, value)</h4><p>Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.</p>
<h4>newrelic.addCustomParameters(params)</h4><p>Set multiple custom parameter values to be attached to a transaction trace and/or
error in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.</p>
<p>Example of setting multiple custom parameters at once:</p>
<pre class="prettyprint source lang-javascript"><code>newrelic.addCustomParameters({test: 'value', test2: 'value2'});</code></pre><h4>newrelic.setIgnoreTransaction(ignored)</h4><p>Tell the module explicitly whether or not a given request should be ignored.
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you <strong>must</strong>
pass <code>false</code> as the parameter – in this case <code>null</code> or <code>undefined</code> will be
ignored.</p>
<h4>newrelic.noticeError(error, customParameters)</h4><p>If your app is doing its own error handling with domains or try/catch clauses,
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
display.</p>
<h4>newrelic.shutdown([options], callback)</h4><p>Use this method to gracefully shut down the agent.  When called with
<code>options.collectPendingData</code> set to true, the agent will send any pending data
to the New Relic servers before shutting down.  This is useful when you want to
shut down the Node process and make sure that all transactions and/or errors are
captured by New Relic.</p>
<p>Example of collecting pending data before shutting down the process:</p>
<pre class="prettyprint source lang-javascript"><code>newrelic.shutdown({ collectPendingData: true }, function(error) {
  process.exit()
})</code></pre><h3>Custom Instrumentation</h3><p>Custom transaction should be used for instrumenting <code>socket.io</code> or other
varieties of socket servers, and background jobs. These are things that the
agent can't automatically instrument because without your knowledge of your
application, the agent can't tell when they should begin and end.</p>
<p>Read more at:
https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-custom-instrumentation</p>
<h4>newrelic.createWebTransaction(url, handle)</h4><p><code>url</code> is the name of the web transaction. It should be pretty static, not
including anything like user ids or any other data that is very specific to the
request. <code>handle</code> is the function you'd like to wrap in the web transaction.
Both custom and auto instrumentation will be captured as part of the
transaction.</p>
<p>If called within an active web transaction, it will act as a nested tracer. If
called within an active background transaction, it will create a new,
independent transaction and any calls within the <code>handle</code> will be bound to the
new web transaction.</p>
<p>Custom transactions <strong>must</strong> be ended manually by calling <code>endTransaction()</code>.
Timing for custom transaction starts from when the returned wrapped function is
called until <code>endTransaction()</code> is called.</p>
<h4>newrelic.createBackgroundTransaction(name, [group], handle)</h4><p><code>name</code> is the name of the job. It should be pretty static, and not include job
ids or anything very specific to that run of the job. <code>group</code> is optional, and
allows you to group types of jobs together. This should follow similar rules as
the <code>name</code>. <code>handle</code> is a function that encompases your background job. Both
custom and auto instrumentation will be captured as part of the transaction.</p>
<p>If called within an active background transaction, it will act as a nested
tracer. If called within an active web transaction, it will create a new
transaction and any calls within the <code>handle</code> will be bound to the new,
independent background transaction.</p>
<p>Custom transactions <strong>must</strong> be ended manually by calling <code>endTransaction()</code>.
Timing for custom transaction starts from when the returned wrapped function is
called until <code>endTransaction()</code> is called.</p>
<h4>newrelic.endTransaction()</h4><p>This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.</p>
<h4>newrelic.createTracer(name, handle)</h4><p><code>name</code> is the name of the tracer. It will show up as a segment in your
transaction traces and create its own metric. <code>handle</code> is the function to be
bound to the tracer.</p>
<p>Timing is from when <code>createTracer</code> is called until the <code>handle</code> done executing.
This should be called inside of a transaction to get data. If it is called
outside of a transaction it will just pass through.</p>
<h4>newrelic.recordMetric(name, value)</h4><p><code>name</code> is the metric name to record, it must be a string that begins with
<code>Custom/</code> typically followed by segments for <code>category</code> and <code>label</code>.
(eg.<code>Custom/my_category/my_label</code>).
<code>value</code> is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If <code>value</code> is
an object, it must include keys for <code>count</code>, <code>total</code>, <code>min</code>, <code>max</code>, and
<code>sumOfSquares</code>.</p>
<h4>newrelic.incrementMetric(name[, amount])</h4><p><code>name</code> is the metric name to record, it must be a string that beings with
<code>Custom/</code> typically followed by segments for <code>category</code> and <code>label</code>.
(eg.<code>Custom/my_category/my_label</code>).
<code>amount</code> is optional, but must be an integer if provided.  <code>amount</code> is
the number of times to increment the metrics <code>count</code>, it defaults to 1.</p>
<h3>The fine print</h3><p>This is the Node-specific version of New Relic's transaction naming API
documentation. The naming API exists to help us deal with the very real problem
that trying to handle too many metrics will make New Relic slow for everybody,
not just the account with too many metrics. If, in conversation with New Relic
Support, you see discussion of &quot;metric explosion&quot;, this is what they're talking
about.</p>
<p>While we have a variety of strategies for dealing with these issues, the most
severe is simply to blacklist offending applications. The main reason for you
to be careful in using our request-naming tools is to prevent that from
happening to your applications. We will do everything in our power to ensure
that you have a good experience with New Relic even if your application is
causing us trouble, but sometimes this will require manual intervention on the
part of our team, and this can take a little while.</p>
<h2>Contributions</h2><p>We owe a debt to all of the beta testers and users who have provided us with
feedback, and in some cases significant pieces of code. (If you wish to
contribute, please see CONTRIBUTING.md in this directory.) In particular, we're
indebted to these people:</p>
<ul>
<li>Hernan Silberman, for his work on the memcached instrumentation.</li>
<li>Jeff Howell &lt;jhowell@kabam.com&gt;, for coming up with a much simpler way
to instrument node-mongodb-native, as well as pointing out a problem with the
Connect instrumentation.</li>
</ul>
<h2>Recent changes</h2><p>Information about changes to the module are in <a href="NEWS.md">NEWS.md</a>.</p>
<h3>Known issues:</h3><ul>
<li>New Relic for Node is only supported on Node.js 0.8 and newer. Some features
may behave differently between 0.8, 0.10 and 0.11 / 0.12. The agent is
optimized for newer versions of Node.</li>
<li>There are irregularities around transaction trace capture and display.  If
you notice missing or incorrect information from transaction traces, let us
know.</li>
<li>There are <del>over 20,000</del> <del>30,000</del> <del>40,000</del> <ins><em>A
LOT</em> of</ins> modules on npm. We can only instrument a tiny number of them.
Even for the modules we support, there are a very large number of ways to use
them. If you see data you don't expect on New Relic and have the time to
produce a reduced version of the code that is producing the strange data, it
will be used to improve the module and you will have the Node team's
gratitude.</li>
<li>The CPU and memory overhead incurred by New Relic for Node is relatively
minor (~1-10%, depending on how much of the instrumentation your apps end up
using). GC activity is significantly increased while the agent is active, due
to the large number of ephemeral objects created by metrics gathering.</li>
<li>When using Node's included clustering support, each worker process will open
its own connection to New Relic's servers, and will incur its own overhead
costs.</li>
</ul>
<h3>New Relic features available for other platforms not yet in Node.js</h3><ul>
<li>custom metrics</li>
<li>explain plans</li>
<li>garbage collector instrumentation</li>
<li>thread profiling</li>
<li>X-ray transactions (depends on thread profiling)</li>
<li>capacity planning</li>
</ul>
<h2>LICENSE</h2><p>New Relic for Node is free-to-use, proprietary software. Please see the full
license (found in <a href="LICENSE">LICENSE</a> in this distribution) for details on its license and
the licenses of its dependencies.</p></article>
    </section>






</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed May 03 2017 17:21:38 GMT-0700 (PDT) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>